<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-ietf-oauth-mtls-17" ipr="trust200902">
  <front>
    <title abbrev="OAuth Mutual TLS">OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access&nbsp;Tokens</title>

    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address><email>brian.d.campbell@gmail.com</email></address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Yubico</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
        <uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
        <email>n-sakimura@nri.co.jp</email>
        <uri>https://nat.sakimura.org/</uri>
      </address>
    </author>

    <author fullname="Torsten Lodderstedt" initials="T." surname="Lodderstedt">
      <organization>YES.com AG</organization>
      <address>
        <email>torsten@lodderstedt.net</email>
      </address>
    </author>


    <date />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>


    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>MTLS</keyword>
    <keyword>Mutual TLS</keyword>
    <keyword>proof-of-possession</keyword>
    <keyword>proof-of-possession access token</keyword>
    <keyword>key confirmed access token</keyword>
    <keyword>certificate-bound access token</keyword>
    <keyword>client certificate</keyword>
    <keyword>X.509 Client Certificate Authentication</keyword>
    <keyword>key confirmation</keyword>
    <keyword>confirmation method</keyword>
    <keyword>holder-of-key</keyword>
    <keyword>OAuth</keyword>


    <abstract>
<t>
  This document describes OAuth client authentication and certificate-bound access and refresh tokens using
  mutual Transport Layer Security (TLS) authentication with X.509 certificates.
  OAuth clients are provided a mechanism for authentication to the authorization
  server using mutual TLS, based on either self-signed certificates or public key infrastructure (PKI).
  OAuth authorization servers are provided a mechanism for binding access tokens to a client's
  mutual TLS certificate, and OAuth protected resources are provided a method for ensuring
  that such an access token presented to it was issued to the client presenting the token.
</t>
    </abstract>

  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
<t>
  The OAuth 2.0 Authorization Framework <xref target="RFC6749"/> enables third-party
  client applications to obtain delegated access to protected resources.
  In the prototypical abstract OAuth flow, illustrated in <xref target="protocol-flow-figure"/>,
  the client obtains an access token from an entity known as an
  authorization server and then uses that token when accessing protected resources,
  such as HTTPS APIs.
</t>
<t>
  <figure title='Abstract OAuth 2.0 Protocol Flow' anchor='protocol-flow-figure'>
    <artwork><![CDATA[
  +--------+                                 +---------------+
  |        |                                 |               |
  |        |<--(A)-- Get an access token --->| Authorization |
  |        |                                 |     Server    |
  |        |                                 |               |
  |        |                                 +---------------+
  |        |                                         ^
  |        |                                         |
  |        |
  |        |                               (C)       |
  | Client |                           Validate the
  |        |                           access token  |
  |        |
  |        |                                         |
  |        |                                         v
  |        |                                 +---------------+
  |        |                                 |      (C)      |
  |        |                                 |               |
  |        |<--(B)-- Use the access token -->|   Protected   |
  |        |                                 |    Resource   |
  |        |                                 |               |
  +--------+                                 +---------------+
]]></artwork>
        </figure>
      </t>
<t>
  The flow illustrated in <xref target="protocol-flow-figure"/> includes the following steps:
  <list style='format (%C)'>
    <t>
      The client makes an HTTPS <spanx style='verb'>POST</spanx> request to
      the authorization server and presents
      a credential representing the authorization grant. For
      certain types of clients (those that have been issued or otherwise established
      a set of client credentials) the request must be authenticated.
      In the response, the authorization server issues an access token to the client.
    </t>
    <t>
      The client includes the access token when making a request to access a protected resource.
    </t>
    <t>
      The protected resource validates the access token in order to authorize the request.
      In some cases, such as when the token is self-contained and cryptographically secured,
      the validation can be done locally by the protected resource.  Other cases require
      that the protected resource call out to the authorization server to determine the state
      of the token and obtain meta-information about it.
    </t>
  </list>
</t>
<t>
  Layering on the abstract flow above,
  this document standardizes enhanced security options for OAuth 2.0 utilizing client-certificate-based mutual TLS.
  <xref target="mtlsca"/> provides options for authenticating the request in step (A). Step (C) is supported
  with semantics to express the binding of the token to the client certificate for both local and remote processing
  in <xref target="x5t"/> and <xref target="introspect"/> respectively. This ensures that, as
  described in <xref target="CertificateBoundAccessTokens"/>, protected resource
  access in step (B) is only possible by the legitimate client bearing the access token and
  holding the private key corresponding to the certificate.
</t>
<t>
  OAuth 2.0
  defines a shared secret method of client authentication but also
  allows for definition and use of additional client authentication mechanisms
  when interacting directly with the authorization server.
  This document describes an additional mechanism of client authentication utilizing
  mutual TLS certificate-based authentication, which provides
  better security characteristics than shared secrets.
  While <xref target="RFC6749"/> documents client authentication for requests to the token endpoint,
  extensions to OAuth 2.0 (such as <xref target="RFC7662">Introspection</xref>,
  <xref target="RFC7009">Revocation</xref>, and the Backchannel Authentication Endpoint
  in <xref target="OpenID.CIBA"/>) define endpoints that also utilize client authentication
  and the mutual TLS methods defined herein are applicable to those endpoints as well.
</t>

<t>
  Mutual TLS certificate-bound access tokens ensure that
  only the party in possession of the
  private key corresponding to the certificate can utilize the token to
  access the associated resources. Such a constraint is
  sometimes referred to as key confirmation, proof-of-possession, or holder-of-key
  and is unlike the case of the
  bearer token described in <xref target="RFC6750"/>, where any party in
  possession of the access token can use it to access the associated resources.
  Binding an access token to the client's certificate
  prevents the use of stolen access tokens or replay of access tokens
  by unauthorized parties.
</t>
<t>
  Mutual TLS certificate-bound access tokens and mutual TLS client authentication
  are distinct mechanisms, which are complementary but don't necessarily need to be deployed or used together.
</t>
<t>
  Additional client metadata parameters are introduced by this document in support of
  certificate-bound access tokens and mutual TLS client authentication.
  The authorization server can obtain client metadata via the
  <xref target="RFC7591">Dynamic Client Registration Protocol</xref>,
  which defines mechanisms for dynamically registering
  OAuth 2.0 client metadata with authorization servers.
  Also the metadata defined by RFC7591, and registered extensions to
  it, imply a general data model for clients that is useful for
  authorization server implementations even when the Dynamic Client
  Registration Protocol isn't in play. Such implementations will typically have
  some sort of user interface available for managing client configuration.
</t>
    <section anchor="RNC" title="Requirements Notation and Conventions">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL"
  in this document are to be interpreted as described in
  BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
  when, and only when, they appear in all capitals, as shown here.
</t>
    </section>

    <section anchor="Terminology" title="Terminology">
<t>
  Throughout this document the term "mutual TLS" refers to the process whereby, in addition to the normal TLS
  server authentication with a certificate, a client presents its X.509 certificate
  and proves possession of the corresponding private key to a server when negotiating a TLS session.

  In contemporary versions of TLS <xref target="RFC8446"/> <xref target="RFC5246"/> this requires that the client send
  the Certificate and CertificateVerify messages during the handshake and
  for the server to verify the CertificateVerify and Finished messages.
</t>
    </section>

    </section>
    <section anchor="mtlsca" title="Mutual TLS for OAuth Client Authentication">
<t>
  This section defines, as an extension of
  <xref target="RFC6749">OAuth 2.0, Section 2.3</xref>, two distinct methods of using
  mutual TLS X.509 client certificates as client credentials.

  The requirement of mutual TLS for client authentication is determined by the authorization server
  based on policy or configuration for the given client (regardless of whether the client was dynamically
  registered, statically configured, or otherwise established).
</t>
<t>
  In order to utilize TLS for OAuth client authentication, the TLS
  connection between the client and the authorization server MUST have been established or reestablished
  with mutual TLS X.509 certificate authentication
  (i.e. the Client Certificate and Certificate Verify messages are sent during the TLS Handshake).
</t>
<t>
  For all requests to the authorization server utilizing mutual TLS client authentication,
  the client MUST include the <spanx style='verb'>client_id</spanx> parameter,
  described in <xref target="RFC6749">OAuth 2.0, Section 2.2</xref>.
  The presence of the <spanx style='verb'>client_id</spanx>
  parameter enables the authorization server to easily identify the
  client independently from the content of the certificate. The authorization server
  can locate the client configuration using the client identifier and check the certificate
  presented in the TLS Handshake against the expected credentials for that client.
  The authorization server MUST enforce the
  binding between client and certificate as described in either <xref target="pki_method"/> or
  <xref target="self_signed_method"/> below.
  If the presented certificate doesn't match that which is expected for the given <spanx style='verb'>client_id</spanx>,
  the authorization server returns a normal OAuth 2.0 error response per <xref target="RFC6749"> Section 5.2 of RFC6749</xref>
  with the <spanx style='verb'>invalid_client</spanx> error code to indicate failed client authentication.
</t>

    <section anchor="pki_method" title="PKI Mutual TLS Method">
      <t>
        The PKI (public key infrastructure) method of mutual TLS OAuth client authentication
        adheres to the way in which X.509 certificates are traditionally used
        for authentication. It relies on a validated certificate chain <xref target="RFC5280"/>
        and a single subject distinguished name (DN) or a single
        subject alternative name (SAN) to authenticate the client.
        Only one subject name value of any type is used for each client.
        The TLS handshake is utilized to validate the client's possession
        of the private key corresponding to the public key in the certificate and to
        validate the corresponding certificate chain. The client is successfully authenticated
        if the subject information in the certificate matches the single expected subject configured or
        registered for that particular client
        (note that a predictable treatment of DN values, such as the distinguishedNameMatch
        rule from <xref target="RFC4517"/>, is needed in comparing the
        certificate's subject DN to the client's registered DN).
        Revocation checking is possible with the PKI method but if and how to check a certificate's
        revocation status is a deployment decision at the discretion of the authorization server.
        Clients can rotate their X.509 certificates
        without the need to modify the respective authentication data at the authorization
        server by obtaining a new certificate with the same subject from a trusted certificate authority (CA).
      </t>

      <section anchor="metadata_auth_value_pki" title="PKI Method Metadata Value">
        <t>
          For the PKI method of mutual TLS client authentication, this specification
          defines and registers the following authentication method metadata
          value into the "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/>.
        </t>
        <t>
          <list style="hanging">
            <t hangText="tls_client_auth">
              <vspace/>
              Indicates that client authentication to the authorization server will occur with
              mutual TLS utilizing the PKI method of associating a certificate to a client.
            </t>
          </list>
        </t>
      </section>

      <section anchor="client_metadata_pki" title="Client Registration Metadata">
        <t>
          In order to convey the expected subject of the certificate,
          the following metadata
          parameters are introduced for the
          <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref> in support of
          the PKI method of mutual TLS client authentication.
          A client using the <spanx style="verb">tls_client_auth</spanx> authentication method MUST use
          exactly one of the below metadata parameters to indicate the certificate subject value that
          the authorization server is to expect when authenticating the respective client.
          <list style="hanging">
            <t hangText="tls_client_auth_subject_dn"><vspace/>
              An <xref target="RFC4514"/> string representation of the expected subject distinguished
              name of the certificate, which the OAuth client will use in mutual TLS authentication.
            </t>

            <t hangText="tls_client_auth_san_dns"><vspace/>
              A string containing the value of an expected dNSName SAN entry
              in the certificate, which the OAuth client will use in mutual TLS
              authentication.
            </t>

            <t hangText="tls_client_auth_san_uri"><vspace/>
              A string containing the value of an expected
              uniformResourceIdentifier SAN entry in the certificate, which
              the OAuth client will use in mutual TLS authentication.
            </t>

            <t hangText="tls_client_auth_san_ip"><vspace/>
              A string representation of an IP address in either dotted decimal
              notation (for IPv4) or colon-delimited hexadecimal (for IPv6, as
              defined in <xref target="RFC4291"/> section 2.2) that is expected to be present
              as an iPAddress SAN entry in the certificate, which the OAuth
              client will use in mutual TLS authentication.
            </t>

            <t hangText="tls_client_auth_san_email"><vspace/>
              A string containing the value of an expected rfc822Name SAN
              entry in the certificate, which the OAuth client will use in
              mutual TLS authentication.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="self_signed_method" title="Self-Signed Certificate Mutual TLS Method">
      <t>
        This method of mutual TLS OAuth client authentication
        is intended to support client authentication using self-signed certificates.
        As a prerequisite, the client registers its X.509 certificates
        (using <spanx style="verb">jwks</spanx> defined in <xref target="RFC7591"/>) or a reference to a trusted source
        for its X.509 certificates (using <spanx style="verb">jwks_uri</spanx> from <xref target="RFC7591"/>)
        with the authorization server. During authentication,
        TLS is utilized to validate the client's possession of the private key
        corresponding to the public key presented within the certificate in the respective TLS handshake. In
        contrast to the PKI method, the client's certificate chain is not validated by the server in this case.
        The client is successfully authenticated if the
        certificate that it presented during the handshake matches one of the certificates
        configured or registered for that particular client.
        The Self-Signed Certificate method allows the use of mutual TLS to authenticate clients without
        the need to maintain a PKI. When used in conjunction with a <spanx style="verb">jwks_uri</spanx> for the
        client, it also allows the client to rotate its X.509 certificates without the
        need to change its respective authentication data directly with the authorization server.
      </t>
      <section anchor="metadata_auth_value_self_signed" title="Self-Signed Method Metadata Value">
        <t>
          For the Self-Signed Certificate method of mutual TLS client authentication, this specification
          defines and registers the following authentication method metadata
          value into the "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/>.
        </t>
        <t>
          <list style="hanging">
            <t hangText="self_signed_tls_client_auth">
              <vspace/>
              Indicates that client authentication to the authorization server will occur using
              mutual TLS with the client utilizing a self-signed certificate.
            </t>
          </list>
        </t>
      </section>

      <section anchor="client_metadata_self_signed" title="Client Registration Metadata">
        <t>
          For the Self-Signed Certificate method of binding a certificate with a client using mutual
          TLS client authentication, the existing
          <spanx style="verb">jwks_uri</spanx> or <spanx style="verb">jwks</spanx>
          metadata parameters from <xref target="RFC7591"/> are used to convey the client's
          certificates via JSON Web Key (JWK) in a JWK Set (JWKS) <xref target="RFC7517"/>.
          The <spanx style="verb">jwks</spanx> metadata parameter is a
          JWK Set containing the client's public keys as an array of JWKs while
          the <spanx style="verb">jwks_uri</spanx> parameter is a URL that references a client's JWK Set.
          A certificate is represented with the <spanx style="verb">x5c</spanx> parameter of an individual JWK within
          the set.
          Note that the members of the JWK representing the public key (e.g. "n" and "e" for RSA,
          "x" and "y" for EC) are required parameters per <xref target="RFC7518"/> so will be present
          even though they are not utilized in this context. Also note that
          that Section 4.7 of <xref target="RFC7517"/> requires that the key
          in the first certificate of the <spanx style="verb">x5c</spanx> parameter match the public
          key represented by those other members of the JWK.
        </t>
      </section>
    </section>

    </section>

    <section anchor="CertificateBoundAccessTokens" title="Mutual TLS Client Certificate-Bound Access Tokens">
<t>
  When mutual TLS is used by the client on the connection to the token endpoint,
  the authorization server is able to bind the issued access token to the client certificate.
  Such a binding is accomplished by associating the certificate with the token in
  a way that can be accessed by the protected resource, such as embedding the certificate
  hash in the issued access token directly, using the syntax described in <xref target="x5t"/>,
  or through token introspection as described in <xref target="introspect"/>.
  Binding the access token to the client certificate in that fashion has the benefit of
  decoupling that binding from the client's authentication with the
  authorization server, which enables mutual TLS during protected resource access to
  serve purely as a proof-of-possession mechanism.
  Other methods of associating a certificate with an access token are possible,
  per agreement by the authorization server and the protected resource, but are
  beyond the scope of this specification.
</t>
<t>
  The client makes protected resource requests as described in <xref target="RFC6750"/>,
  however, those requests MUST be made over a mutually authenticated TLS connection
  using the same certificate that was used for mutual TLS at the token endpoint.
</t>
<t>
  The protected resource MUST obtain, from its TLS implementation layer, the client certificate
  used for mutual TLS
  and MUST verify that the certificate matches the
  certificate associated with the access token.  If they do not match,
  the resource access attempt MUST be rejected with an error per <xref target="RFC6750"/>
  using an HTTP 401 status code and the <spanx style="verb">invalid_token</spanx> error code.
</t>
<t>
  Metadata to convey server and client capabilities for mutual TLS client certificate-bound access tokens
  is defined in <xref target="server_metadata_at"/> and <xref target="client_metadata_at"/> respectively.
</t>

      <section anchor="x5t" title="JWT Certificate Thumbprint Confirmation Method">
  <t>
    When access tokens are represented as JSON Web Tokens (JWT)<xref target="RFC7519"/>,
    the certificate hash information SHOULD be represented using
    the <spanx style="verb">x5t#S256</spanx> confirmation method member defined herein.
  </t>
  <t>
    To represent the hash of a certificate in a JWT,
    this specification defines the new <xref target="RFC7800">JWT Confirmation Method</xref>
    member <spanx style="verb">x5t#S256</spanx> for the X.509 Certificate SHA-256 Thumbprint.
    The value of the <spanx style="verb">x5t#S256</spanx> member is a base64url-encoded <xref target="RFC4648"/>
    SHA-256 <xref target="SHS"/> hash (a.k.a. thumbprint, fingerprint or digest) of the DER encoding <xref target="X690"/> of the X.509 certificate
    <xref target="RFC5280"/>. The base64url-encoded value MUST omit all trailing pad '=' characters
    and MUST NOT include any line breaks, whitespace, or other additional characters.
  </t>
  <t>
    The following is an example of a JWT payload containing an <spanx style="verb">x5t#S256</spanx> certificate thumbprint
    confirmation method. The new JWT content introduced by this specification is the <spanx style="verb">cnf</spanx>
    confirmation method claim at the bottom of the example that has
    the <spanx style="verb">x5t#S256</spanx> confirmation method member containing the value that is the hash
    of the client certificate to which the access token is bound.
  </t>

  <figure anchor="eg_x5ts256jwt" title="Example JWT Claims Set with an X.509 Certificate Thumbprint Confirmation Method">
    <artwork><![CDATA[
  {
    "iss": "https://server.example.com",
    "sub": "ty.webb@example.com",
    "exp": 1493726400,
    "nbf": 1493722800,
    "cnf":{
      "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
  }]]>
    </artwork>
  </figure>

      </section>

      <section anchor="introspect" title="Confirmation Method for Token Introspection">
        <t>
          <xref target="RFC7662">OAuth 2.0 Token Introspection</xref> defines a
          method for a protected resource to query
          an authorization server about the active state of an
          access token as well as to determine meta-information about the token.
        </t>
        <t>
          For a mutual TLS client certificate-bound access token, the hash of the
          certificate to which the token is bound
          is conveyed to the protected resource as meta-information
          in a token introspection response. The hash is conveyed using the same
          <spanx style="verb">cnf</spanx> with <spanx style="verb">x5t#S256</spanx> member structure as the
          certificate SHA-256 thumbprint confirmation method, described in
          <xref target="x5t"/>, as a top-level member of the introspection response JSON.
          The protected resource compares
          that certificate hash to a hash of the client certificate used for
          mutual TLS authentication
          and rejects the request, if they do not match.
        </t>

        <t>
          The following is an example of an introspection response for an active token with
          an <spanx style="verb">x5t#S256</spanx> certificate thumbprint
          confirmation method. The new introspection response content introduced by this specification is the <spanx style="verb">cnf</spanx>
          confirmation method at the bottom of the example that has
          the <spanx style="verb">x5t#S256</spanx> confirmation method member containing the value that is the hash
          of the client certificate to which the access token is bound.
        </t>

        <figure anchor="eg_x5ts256intro" title="Example Introspection Response for a Certificate-Bound Access Token">
          <artwork><![CDATA[

  HTTP/1.1 200 OK
  Content-Type: application/json

  {
    "active": true,
    "iss": "https://server.example.com",
    "sub": "ty.webb@example.com",
    "exp": 1493726400,
    "nbf": 1493722800,
    "cnf":{
      "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
  }]]>
          </artwork>
        </figure>

      </section>

      <section anchor="server_metadata_at" title="Authorization Server Metadata">
          <t>This document introduces the following new authorization server
            metadata <xref target="RFC8414"/> parameter to signal the server's capability to issue certificate
            bound access tokens:

            <list style="hanging">
              <t hangText="tls_client_certificate_bound_access_tokens"><vspace/>
                OPTIONAL.  Boolean value indicating server support for
                mutual TLS client certificate-bound access tokens. If omitted, the
                default value is <spanx style="verb">false</spanx>.
              </t>
            </list>
          </t>
        </section>

      <section anchor="client_metadata_at" title="Client Registration Metadata">
        <t>The following new client
          metadata parameter is introduced to convey the client's intention to use certificate
          bound access tokens:

          <list style="hanging">
            <t hangText="tls_client_certificate_bound_access_tokens"><vspace/>
              OPTIONAL. Boolean value used to indicate the client's intention
              to use mutual TLS client certificate-bound access tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
            </t>
          </list>
        </t>
        </section>

      </section>

    <section anchor="PubClient" title="Public Clients and Certificate-Bound Tokens">
      <t>
        Mutual TLS OAuth client authentication and certificate-bound access tokens
        can be used independently of each other.
        Use of certificate-bound access tokens without mutual TLS OAuth client authentication, for example,
        is possible in support of binding access tokens to a TLS client certificate for public clients (those without
        authentication credentials associated with the <spanx style="verb">client_id</spanx>).
        The authorization server would configure the TLS stack in the same manner as for the Self-Signed Certificate method
        such that it does not verify that the certificate presented by the client during the handshake is
        signed by a trusted CA. Individual instances of a client would create a self-signed
        certificate for mutual TLS with both the authorization server and resource server. The authorization
        server would not use the mutual TLS certificate to authenticate the client at the OAuth layer
        but would bind the issued access token
        to that certificate, for which the client has proven possession of the corresponding private key.
        The access token is then bound to the certificate and can only be used by the client
        possessing the certificate and corresponding private key and utilizing them to negotiate mutual TLS on
        connections to the resource server.
        When the authorization server issues a refresh token to such a client, it SHOULD also bind the refresh token
        to the respective certificate. And check the binding when the refresh token is presented to get new
        access tokens.
        The implementation details of the binding the refresh token are at the discretion of the authorization
        server.
      </t>
    </section>

    <section anchor="endpointAliases" title="Metadata for Mutual TLS Endpoint Aliases">
      <t>
        The process of negotiating client certificate-based mutual TLS involves a TLS server requesting a certificate
        from the TLS client (the client does not provide one unsolicited). Although a server can be configured
        such that client certificates are optional, meaning that the connection is allowed to continue when the client
        does not provide a certificate, the act of a server requesting a certificate can result in undesirable
        behavior from some clients. This is particularly true of web browsers as TLS clients, which will typically
        present the end-user with an intrusive certificate selection interface when the server requests a certificate.
      </t>
      <t>
        Authorization servers supporting both clients using mutual TLS and conventional clients MAY chose to
        isolate the server side mutual TLS behaviour to only clients intending to do mutual TLS, thus
        avoiding any undesirable effects it might have on conventional clients. The following authorization server
        metadata parameter is introduced to facilitate such separation:
      </t>
      <t>
        <list style="hanging">
          <t hangText="mtls_endpoint_aliases">
            <vspace/>OPTIONAL.
            A JSON object containing alternative authorization server endpoints that,
            when present, an OAuth client intending to do mutual TLS
            uses in preference to the conventional endpoints.
            The parameter value itself consists of one or more endpoint parameters,
            such as <spanx style="verb">token_endpoint</spanx>,
            <spanx style="verb">revocation_endpoint</spanx>,
            <spanx style="verb">introspection_endpoint</spanx>, etc., conventionally defined for the
            top-level of authorization server metadata.
            An OAuth client intending to do mutual TLS
            (for OAuth client authentication and/or to acquire or use certificate-bound tokens)
            when making a request directly to the authorization server MUST
            use the alias URL of the endpoint within the <spanx style="verb">mtls_endpoint_aliases</spanx>, when present,
            in preference to the endpoint URL of the same name at top-level of metadata.
            When an endpoint is not present in
            <spanx style="verb">mtls_endpoint_aliases</spanx>, then the client uses the conventional endpoint URL
            defined at the top-level of the authorization server metadata. Metadata parameters within
            <spanx style="verb">mtls_endpoint_aliases</spanx> that do not define
            endpoints to which an OAuth client makes a direct request have no meaning and SHOULD be ignored.
          </t>
        </list>

      </t>
      <t>
        Below is an example of an authorization server metadata document with the
        <spanx style="verb">mtls_endpoint_aliases</spanx> parameter, which indicates aliases for the
        token, revocation, and introspection endpoints that an OAuth client intending to do mutual TLS
        would in preference to the conventional token, revocation, and introspection endpoints.
        Note that the endpoints in <spanx style="verb">mtls_endpoint_aliases</spanx> use a different
        host than their conventional counterparts, which allows the authorization server
        (via TLS <spanx style="verb">server_name</spanx> extension <xref target="RFC6066"/> or actual distinct hosts) to differentiate its TLS behavior as appropriate.

        <figure title='Example Authorization Server Metadata with Mutual TLS Endpoint Aliases' anchor='as-meta'>
          <artwork><![CDATA[
{
  "issuer": "https://server.example.com",
  "authorization_endpoint": "https://server.example.com/authz",
  "token_endpoint": "https://server.example.com/token",
  "introspection_endpoint": "https://server.example.com/introspect",
  "revocation_endpoint": "https://server.example.com/revo",
  "jwks_uri": "https://server.example.com/jwks",
  "response_types_supported": ["code"],
  "response_modes_supported": ["fragment","query","form_post"],
  "grant_types_supported": ["authorization_code", "refresh_token"],
  "token_endpoint_auth_methods_supported":
                  ["tls_client_auth","client_secret_basic","none"],
  "tls_client_certificate_bound_access_tokens": true
  "mtls_endpoint_aliases": {
    "token_endpoint": "https://mtls.example.com/token",
    "revocation_endpoint": "https://mtls.example.com/revo",
    "introspection_endpoint": "https://mtls.example.com/introspect"
  }
}
]]></artwork>
        </figure>



      </t>
    </section>

    <section anchor="Impl" title="Implementation Considerations">
    <section anchor="ImplAS" title="Authorization Server">
    <t>The authorization server needs to set up its TLS configuration appropriately
    for the OAuth client authentication methods it supports.</t>
    <t>An authorization server that supports mutual TLS client authentication
    and other client authentication methods or public clients in parallel would make mutual TLS
    optional (i.e. allowing a handshake to continue after the server requests a client certificate
    but the client does not send one).</t>
    <t>In order to support the Self-Signed Certificate method, the authorization server
    would configure the TLS stack in such a way that it does not verify whether the
    certificate presented by the client during the handshake is signed by a trusted CA 
    certificate.</t>
    <t>As described in <xref target="CertificateBoundAccessTokens"/>, the authorization server
    binds the issued access token to the TLS client certificate, which means that it
    will only issue certificate-bound tokens for a
    certificate which the client has proven possession of the corresponding private key.</t>
    <t>The authorization server may also consider hosting the token endpoint,
    and other endpoints requiring client authentication, on
    a separate host name or port in order to prevent unintended impact on the TLS behavior of
    its other endpoints, e.g. the authorization endpoint. As described in <xref target="endpointAliases"/>,
    it may further isolate any potential impact of the server requesting client certificates by
    offering a distinct set of endpoints on a separate host or port, which are aliases for
    the originals that a client intending to do mutual TLS will use in preference to the conventional endpoints.</t>
    </section>
    <section anchor="ImplRS" title="Resource Server">
    <t>
      OAuth divides the roles and responsibilities such that the resource server relies
      on the authorization server to perform client authentication and obtain resource owner (end-user)
      authorization. The resource server makes authorization decisions based on the access token
      presented by the client but does not directly authenticate the client per se.
      The manner in which an access token is bound to the client certificate
      decouples it from the specific method that the client used to authenticate with the
      authorization server. Mutual TLS during protected resource access can therefore
      serve purely as a proof-of-possession mechanism.
      As such, it is not necessary for the resource server to validate
      the trust chain of the client's certificate in any of the methods
      defined in this document.
      The resource server would therefore configure the TLS stack
      in a way that it does not verify whether the certificate presented by the client
      during the handshake is signed by a trusted CA certificate.
    </t>
    </section>
    <section anchor="ImplExp" title="Certificate Expiration and Bound Access Tokens">
      <t>
        As described in <xref target="CertificateBoundAccessTokens"/>,
        an access token is bound to a specific client certificate, which means that
        the same certificate must be used for mutual TLS on protected resource access.
        It also implies that access tokens are invalidated when a client updates the certificate,
        which can be handled similar to expired access tokens where the client
        requests a new access token (typically with a refresh token) and retries the protected resource
        request.
      </t>
    </section>
    <section anchor="ImplImplicit" title="Implicit Grant Unsupported">
    <t>
      This document describes binding an access token to the
      client certificate presented on the TLS connection from the client to the
      authorization server's token endpoint,
      however, such binding of access tokens issued directly from the authorization
      endpoint via the implicit grant flow is explicitly out of scope.
      End users interact directly with the authorization endpoint using a web browser
      and the use of client certificates in user's browsers bring operational and
      usability issues, which make it undesirable to support certificate-bound access
      tokens issued in the implicit grant flow. Implementations wanting to employ
      certificate-bound access tokens should utilize grant types
      that involve the client making an access token request directly to the token endpoint
      (e.g. the authorization code and refresh token grant types).
    </t>
    </section>
    <section anchor="TTRP" title="TLS Termination">
    <t>
      An authorization server or resource server MAY choose to terminate TLS connections at a load balancer,
      reverse proxy, or other network intermediary. How the client certificate metadata is securely
      communicated between the intermediary and the application server in this case is out of scope of this specification.
    </t>
    </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <section title="Certificate-Bound Refresh Tokens">
        <t>The OAuth 2.0 Authorization Framework <xref target="RFC6749"/> requires that an authorization server
          bind refresh tokens to the client to which they were issued and that confidential clients
          (those having established authentication credentials with the authorization server) authenticate to
          the AS when presenting a refresh token. As a result, refresh tokens are indirectly certificate-bound when
          issued to clients utilizing the <spanx style="verb">tls_client_auth</spanx> or
          <spanx style="verb">self_signed_tls_client_auth</spanx> methods of client authentication.
          <xref target="PubClient"/> describes certificate-bound refresh tokens issued to public clients (those without
          authentication credentials associated with the <spanx style="verb">client_id</spanx>).
        </t>
      </section>
      <section title="Certificate Thumbprint Binding">
        <t>
          The binding between the certificate and access token specified in <xref target="x5t"/> uses
          a cryptographic hash of the certificate. It relies on the hash function having sufficient
          preimage and second-preimage resistance so as to make it computationally infeasible to
          find or create another certificate that produces to the same hash output value.
          The SHA-256 hash function was used because it meets the aforementioned requirement while being widely available.
          If, in the future, certificate thumbprints need to be computed using
          hash function(s) other than SHA-256, it is suggested that additional
          related JWT confirmation methods members be defined for that purpose
          and registered in the IANA "JWT Confirmation Methods" registry
          <xref target="IANA.JWT.Claims"/>
          for JWT <spanx style="verb">cnf</spanx> member values.
        </t>
      </section>
      <section anchor="TLSV" title="TLS Versions and Best Practices">
        <t>
          In the abstract this document is applicable with any TLS version supporting certificate-based client authentication.
          Both <xref target="RFC8446">TLS 1.3</xref> and <xref target="RFC5246">TLS 1.2</xref> are cited herein because,
          at the time of writing, 1.3 is the newest version while 1.2 is the most widely deployed.
          General implementation and security considerations for TLS, including version recommendations,
          can be found in <xref target="BCP195"/>.
        </t>
      </section>
      <section anchor="certspoofing" title="X.509 Certificate Spoofing">
        <t>
          If the PKI method of client authentication is used, an attacker could try to impersonate a client using
          a certificate with the same subject (DN or SAN) but issued by a different CA, which the authorization server trusts.
          To cope with that threat, the authorization server SHOULD only accept as trust anchors
          a limited number of CAs whose certificate issuance policy meets its security requirements.
          There is an assumption then that the client and server agree out of band on the set
          of trust anchors that the server uses to create and validate the
          certificate chain. Without this assumption the use of a subject
          to identify the client certificate would open the server up to
          certificate spoofing attacks.
        </t>
      </section>
      <section title="X.509 Certificate Parsing and Validation Complexity">
        <t>
          Parsing and validation of X.509 certificates and certificate chains is complex and implementation
          mistakes have previously exposed security vulnerabilities.
          Complexities of validation include (but are not limited to)
          <xref target="CX5P"/> <xref target="DCW"/> <xref target="RFC5280"/>:
        </t>
        <t>
          <list style="symbols">
          <t>checking of Basic Constraints, basic and extended Key Usage constraints, validity periods, and critical extensions;</t>
          <t>handling of null-terminator bytes and non-canonical string representations in subject names;</t>
          <t>handling of wildcard patterns in subject names;</t>
          <t>recursive verification of certificate chains and checking certificate revocation.</t>
          </list>
        </t><t>
          For these reasons, implementors SHOULD use an established and well-tested X.509 library
          (such as one used by an established TLS library) for validation of X.509 certificate chains
          and SHOULD NOT attempt to write their own X.509 certificate validation procedures.
        </t>
      </section>
    </section>

    <section anchor="Privacy" title="Privacy Considerations">
      <t>
        In TLS versions prior to 1.3, the client's certificate is sent unencrypted in the initial handshake and
        can potentially be used by third parties to monitor, track, and correlate client activity.
        This is likely of little concern for clients that act on behalf of a significant number of end-users because
        individual user activity will not be discernible amidst the client activity as a whole.
        However, clients that act on behalf of a single end-user, such as a native application on a mobile device,
        should use TLS version 1.3 whenever possible or consider the potential privacy implications of using mutual TLS on
        earlier versions.
      </t>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section title="JWT Confirmation Methods Registration">
        <t>
          This specification requests registration of the following value
          in the IANA "JWT Confirmation Methods" registry
          <xref target="IANA.JWT.Claims"/>
          for JWT <spanx style="verb">cnf</spanx> member values
          established by <xref target="RFC7800"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Confirmation Method Value: <spanx style="verb">x5t#S256</spanx></t>
            <t>Confirmation Method Description: X.509 Certificate SHA-256 Thumbprint</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="x5t"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
      
      <section title="Authorization Server Metadata Registration">
        <t>
          This specification requests registration of the following values
          in the IANA "OAuth Authorization Server Metadata" registry
          <xref target="IANA.OAuth.Parameters"/> established by <xref target="RFC8414"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Metadata Name: <spanx style="verb">tls_client_certificate_bound_access_tokens</spanx></t>
            <t>Metadata Description: Indicates authorization server support for mutual TLS client certificate-bound
              access tokens.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="server_metadata_at"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Metadata Name: <spanx style="verb">mtls_endpoint_aliases</spanx></t>
            <t>Metadata Description: JSON object containing alternative authorization server endpoints, which a client
              intending to do mutual TLS will use in preference to the conventional endpoints.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="endpointAliases"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>

      <section title="Token Endpoint Authentication Method Registration">
        <t>
          This specification requests registration of the following values
          in the IANA "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/> established by <xref target="RFC7591"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">tls_client_auth</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="metadata_auth_value_pki"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">self_signed_tls_client_auth</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="metadata_auth_value_self_signed"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>

      <section title="Token Introspection Response Registration">
        <t>
          <xref target="RFC7800">Proof-of-Possession Key Semantics for JSON Web Tokens</xref> defined the
          <spanx style="verb">cnf</spanx> (confirmation) claim, which enables
          confirmation key information to be carried in a JWT.
          However, the same proof-of-possession semantics are also useful for introspected access tokens
          whereby the protected resource obtains the confirmation key data as meta-information
          of a token introspection response and uses that information in verifying proof-of-possession.
          Therefore this specification defines and registers proof-of-possession semantics for
          <xref target="RFC7662">OAuth 2.0 Token Introspection</xref> using the <spanx style="verb">cnf</spanx>
          structure.
          When included as a top-level member of an OAuth token introspection response, <spanx style="verb">cnf</spanx>
          has the same semantics and format as the claim of the same name defined in <xref target="RFC7800"/>.
          While this specification only explicitly uses the <spanx style="verb">x5t#S256</spanx>
          confirmation method member (see <xref target="introspect"/>), it needs to define and register
          the higher level <spanx style="verb">cnf</spanx>
          structure as an introspection response member in order to define and use the more specific
          certificate thumbprint confirmation method.
        </t>
        <t>
          As such, this specification requests registration of the following value
          in the IANA "OAuth Token Introspection Response" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7662"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Claim Name: <spanx style="verb">cnf</spanx></t>
            <t>Claim Description: Confirmation</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="RFC7800"/> and [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>


      <section title="Dynamic Client Registration Metadata Registration">
        <t>
          This specification requests registration of the following client metadata definitions
          in the IANA "OAuth Dynamic Client Registration Metadata" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7591"/>:
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_certificate_bound_access_tokens</spanx>
            </t>
            <t>
              Client Metadata Description:
              Indicates the client's intention to use mutual TLS client certificate-bound
              access tokens.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_at"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_subject_dn</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected subject DN of the client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_san_dns</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected dNSName SAN entry in the client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_san_uri</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected uniformResourceIdentifier SAN entry in the client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_san_ip</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected iPAddress SAN entry in the client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_san_email</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected rfc822Name SAN entry in the client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.4514'?> <!-- LDAP: String Representation of Distinguished Names -->
      <?rfc include='reference.RFC.4648'?> <!-- base64 -->
      <?rfc include='reference.RFC.5246'?> <!-- TLS 1.2 -->
      <?rfc include='reference.RFC.5280'?> <!-- X.509 Public Key Infrastructure Certificate ... -->
      <?rfc include='reference.RFC.6749'?> <!-- OAuth 2.0 Authorization Framework -->
      <?rfc include='reference.RFC.6750'?> <!-- OAuth 2.0 Authorization Framework: Bearer Token Usage -->
      <?rfc include='reference.RFC.7517'?> <!-- JWK -->
      <?rfc include='reference.RFC.7519'?> <!-- JWT -->
      <?rfc include='reference.RFC.7591'?> <!-- Dynamic Client Registration -->
      <?rfc include='reference.RFC.7662'?> <!-- introspection -->
      <?rfc include='reference.RFC.7800'?>
      <?rfc include='reference.RFC.8174'?>

      <?rfc include='reference.RFC.8414'?> <!-- OAuth AS metadata -->

      <?rfc include='reference.RFC.8446'?> <!-- TLS 1.3 -->

      <reference anchor="BCP195" target="http://www.rfc-editor.org/info/bcp195">
        <front>
          <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
          <author initials="Y." surname="Sheffer" fullname="Y. Sheffer">
            <organization/>
          </author>
          <author initials="R." surname="Holz" fullname="R. Holz">
            <organization/>
          </author>
          <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
            <organization/>
          </author>
          <date year="2015" month="May"/>
          <abstract>
            <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP. Over the last
              few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation. This document provides recommendations for improving the
              security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.
            </t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="195"/>
        <seriesInfo name="RFC" value="7525"/>
        <seriesInfo name="DOI" value="10.17487/RFC7525"/>
      </reference>

      <reference anchor="SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
              Technology</organization>
          </author>

          <date month="March" year="2012" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" type="PDF" />
      </reference>

      <reference anchor="X690">
        <front>
            <title>
                ASN.1 encoding rules: Specification of basic encoding Rules (BER),
                Canonical encoding rules (CER) and Distinguished encoding rules (DER)
            </title>
            <author>
                <organization>
                    International Telephone and Telegraph Consultative Committee
                </organization>
            </author>
            <date month="July" year="2015"/>
        </front>
        <seriesInfo name="CCITT" value="Recommendation X.690"/>
      </reference>

    </references>

    <references title="Informative References">
      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="IANA.JWT.Claims" target="http://www.iana.org/assignments/jwt">
        <front>
          <title>JSON Web Token Claims</title>
          <author>
            <organization>IANA</organization>
          </author>
          <date/>
        </front>
      </reference>

      <?rfc include='reference.RFC.4291'?> <!-- IPv6 -->
      <?rfc include='reference.RFC.4517'?>
      <?rfc include='reference.RFC.6066'?>
      <?rfc include='reference.RFC.7009'?> <!-- revocation -->
      <?rfc include='reference.RFC.7518'?> <!-- JWA -->



      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-token-binding-06.xml'?>

      <reference anchor="CX5P" target="https://www.cryptologie.net/article/374/common-x509-certificate-validationcreation-pitfalls">
        <front>
          <title>Common x509 certificate validation/creation pitfalls</title>
          <author fullname="David Wong" initials="D." surname="Wong"><organization/></author>
          <date month="September" year="2016"/>
        </front>
      </reference>

      <reference anchor="DCW" target="http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf">
        <front>
          <title>The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software</title>
          <author fullname="Martin Georgiev" initials="M." surname="Georgiev"><organization/></author>
          <author fullname="Subodh Iyengar" initials="S." surname="Iyengar"><organization/></author>
          <author fullname="Suman Jana" initials="S." surname="Jana"><organization/></author>
          <author fullname="Rishita Anubhai" initials="R." surname="Anubhai"><organization/></author>
          <author fullname="Dan Boneh" initials="D." surname="Boneh"><organization/></author>
          <author fullname="Vitaly Shmatikov" initials="V." surname="Shmatikov"><organization/></author>
          <date/>
        </front>
      </reference>

      <reference anchor="OpenID.CIBA"
           target="https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html">
        <front>
          <title abbrev="CIBA">OpenID Connect Client Initiated Backchannel Authentication Flow - Core 1.0</title>
          <author fullname="Gonzalo Fernandez Rodriguez" initials="G." surname="Fernandez">
            <organization abbrev="Telefonica">Telefonica I+D</organization>
            <address>
              <email>gonzalo.fernandezrodriguez@telefonica.com</email>
            </address>
          </author>
          <author fullname="Florian Walter" initials="F." surname="Walter">
            <organization abbrev="">Deutsche Telekom AG</organization>
            <address>
              <email>F.Walter@telekom.de</email>
            </address>
          </author>
          <author fullname="Axel Nennker" initials="A." surname="Nennker">
            <organization abbrev="">Deutsche Telekom AG</organization>
            <address>
              <email>axel.nennker@telekom.de</email>
            </address>
          </author>
          <author fullname="Dave Tonge" initials="D." surname="Tonge">
            <organization abbrev="Moneyhub">Moneyhub</organization>
            <address>
              <email>dave.tonge@moneyhub.com</email>
            </address>
          </author>
          <author fullname="Brian Campbell" initials="B." surname="Campbell">
            <organization abbrev="Ping Identity">Ping Identity</organization>
            <address>
              <email>bcampbell@pingidentity.com</email>
            </address>
          </author>
          <date day="16" month="January" year="2019"/>
        </front>
      </reference>

    </references>

    <section title='Example "cnf" Claim, Certificate and JWK' anchor="example">
      <t>
        For reference, an <spanx style="verb">x5t#S256</spanx> value and the X.509 Certificate from which it was
        calculated are provided in the following examples, <xref target="cnf"/> and <xref target="pem"/> respectively.
        A JWK representation of the certificate's public
        key along with the <spanx style="verb">x5c</spanx> member is also provided in <xref target="jwk"/>.

        <figure title="x5t#S256 Confirmation Claim" anchor="cnf">
          <artwork><![CDATA["cnf":{"x5t#S256":"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0"}
]]></artwork>
        </figure>

        <figure title="PEM Encoded Self-Signed Certificate" anchor="pem">
          <artwork><![CDATA[-----BEGIN CERTIFICATE-----
MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTAx
ODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGByqG
SM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZjjJ
/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0EAwID
SQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2eXZOV
bUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=
-----END CERTIFICATE-----]]></artwork>
        </figure>

        <figure title="JSON Web Key" anchor="jwk">
          <artwork><![CDATA[
{
 "kty":"EC",
 "x":"1yfLHCpXqFjxCeHHHMVDTcLscpb07KUxudBmOMn8C7Q",
 "y":"8_coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8",
 "crv":"P-256",
 "x5c":[
  "MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTA
   xODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGBy
   qGSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZ
   jjJ/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0E
   AwIDSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2
   eXZOVbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY="
   ]
 }]]></artwork>
        </figure>
      </t>
    </section>

    <section anchor="relation" title="Relationship to Token Binding">
      <t>
        <xref target="I-D.ietf-oauth-token-binding">OAuth 2.0 Token Binding</xref>
        enables the application of Token Binding to the various artifacts and tokens employed throughout OAuth.
        That includes binding of an access token to a Token Binding key, which bears some similarities in motivation
        and design to the mutual TLS client certificate-bound access tokens defined in this document.
        Both documents define what is often called a proof-of-possession security mechanism
        for access tokens, whereby a client must demonstrate possession of cryptographic keying
        material when accessing a protected resource. The details differ somewhat between the two documents but both
        have the authorization server bind the access token that it issues to an asymmetric key pair
        held by the client. The client then proves possession of the private key from that pair
        with respect to the TLS connection over which the protected resource is accessed.
      </t>
      <t>
        Token Binding uses bare keys that are generated on the client,
        which avoids many of the difficulties of creating, distributing, and managing certificates
        used in this specification. However, at the time of
        writing, Token Binding is fairly new and there is relatively little support for it in available
        application development platforms and tooling. Until better support for the underlying
        core Token Binding specifications exists, practical implementations of OAuth 2.0 Token Binding
        are infeasible. 
        Mutual TLS, on the other hand, has been around for some time and enjoys
        widespread support in web servers and development platforms.  As a consequence, OAuth 2.0 Mutual TLS
        Client Authentication and Certificate-Bound Access Tokens can be
        built and deployed now using existing platforms and tools.
        In the future, the two specifications are likely to be
        deployed in parallel for solving similar problems in different environments.
        Authorization servers may even support both specifications simultaneously using different
        proof-of-possession mechanisms for tokens issued to different clients.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        Scott "not Tomlinson" Tomilson and Matt Peterson were involved in
        design and development work on a mutual TLS OAuth client authentication
        implementation, which predates this document. Experience and learning from that work
        informed some of the content of this document.
      </t>

      <t>
        This specification was developed within the OAuth Working Group
        under the chairmanship of Hannes Tschofenig
        and Rifaat Shekh-Yusef with Eric Rescorla, Benjamin Kaduk, and Roman Danyliw
        serving as Security Area Directors.  Additionally, the following
        individuals contributed ideas, feedback, and wording
        that helped shape this specification:
        Vittorio Bertocci,
        Sergey Beryozkin,
        Ralph Bragg,
        Sophie Bremer,
        Roman Danyliw,
        Vladimir Dzhuvinov,
        Samuel Erdtman,
        Evan Gilman,
        Leif Johansson,
        Michael Jones,
        Phil Hunt,
        Benjamin Kaduk,
        Takahiko Kawasaki,
        Sean Leonard,
        Kepeng Li,
        Neil Madden,
        James Manger,
        Jim Manico,
        Nov Matake,
        Sascha Preibisch,
        Eric Rescorla,
        Justin Richer,
        Vincent Roca,
        Filip Skokan,
        Dave Tonge,
        and
        Hannes Tschofenig.
      </t>
    </section>


    <section anchor="History" title="Document(s) History">
      <?rfc subcompact="yes"?>
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>
      <t>
        draft-ietf-oauth-mtls-17
        <list style='symbols'>
          <t>Editorial updates from IESG ballot position comments.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-16
        <list style='symbols'>
          <t>Editorial updates from last call review.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-15
        <list style='symbols'>
          <t>Editorial updates from second AD review.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-14
        <list style='symbols'>
          <t>Editorial clarifications around there being only a single subject registered/configured per client
            for the tls_client_auth method.</t>
          <t>Add a brief explanation about how, with tls_client_auth and self_signed_tls_client_auth,
            refresh tokens are certificate-bound indirectly via the client authentication.</t>
          <t>Add mention of refresh tokens in the abstract.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-13
        <list style='symbols'>
          <t>Add an abstract protocol flow and diagram to serve as an overview of OAuth in general and
            baseline to describe the various ways
            in which the mechanisms defined herein are intended to be used.</t>
          <t>A little bit less of that German influence.</t>
          <t>Rework the TLS references a bit and, in the Terminology section, clean up the description
            of what messages are sent and verified in the handshake to do 'mutual TLS'.</t>
          <t>Move the explanation about "cnf" introspection registration
            into the IANA Considerations.</t>
          <t>Add CIBA as an informational reference and additional example of an OAuth extension that
            defines an endpoint that utilizes client authentication.</t>
          <t>Shorten a few of the section titles.</t>
          <t>Add new client metadata values to allow for the use of a SAN in the PKI MTLS client authentication method.</t>
          <t>Add privacy considerations attempting to discuss the implications of the client cert being sent in
            the clear in TLS 1.2.</t>
          <t>Changed the 'Certificate Bound Access Tokens Without Client Authentication' section to
            'Public Clients and Certificate-Bound Tokens' and moved it up to be a top level section
            while adding discussion of binding refresh tokens for public clients.</t>
          <t>Reword/restructure the main PKI method section somewhat to (hopefully) improve readability.</t>
          <t>Reword/restructure the Self-Signed method section a bit to (hopefully) make it more comprehensible.</t>
          <t>Reword the AS and RS Implementation Considerations somewhat to (hopefully) improve readability.</t>
          <t>Clarify that the protected resource obtains the client certificate used for mutual TLS from its TLS implementation layer.</t>
          <t>Add Security Considerations section about the certificate thumbprint binding that includes the hash algorithm agility recommendation.</t>
          <t>Add an "mtls_endpoint_aliases" AS metadata parameter that is a JSON object containing alternative authorization
            server endpoints, which a client intending to do mutual TLS will use in preference to the conventional endpoints.</t>
          <t>Minor editorial updates.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-12
        <list style='symbols'>
          <t>Add an example certificate, JWK, and confirmation method claim.</t>
          <t>Minor editorial updates based on implementer feedback.</t>
          <t>Additional Acknowledgements.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-11
        <list style='symbols'>
          <t>Editorial updates.</t>
          <t>Mention/reference TLS 1.3 RFC8446 in the TLS Versions and Best Practices section.</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-10
        <list style='symbols'>
          <t>Update draft-ietf-oauth-discovery reference to RFC8414</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-09
        <list style='symbols'>
          <t>Change "single certificates" to "self-signed certificates" in the Abstract</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-08
        <list style='symbols'>
          <t>Incorporate clarifications and editorial improvements from Justin Richer's WGLC review</t>
          <t>Drop the use of the "sender constrained" terminology per WGLC feedback from Neil Madden (including changing
          the metadata parameters from mutual_tls_sender_constrained_access_tokens
            to tls_client_certificate_bound_access_tokens)</t>
          <t>Add a new security considerations section on X.509 parsing and validation
            per WGLC feedback from Neil Madden and Benjamin Kaduk</t>
          <t>Note that a server can terminate TLS at a load balancer, reverse proxy, etc. but how the
            client certificate metadata is securely communicated to the backend is out of scope per WGLC feedback</t>
          <t>Note that revocation checking is at the discretion of the AS per WGLC feedback</t>
          <t>Editorial updates and clarifications</t>
          <t>Update draft-ietf-oauth-discovery reference to -10 and draft-ietf-oauth-token-binding to -06</t>
          <t>Add folks involved in WGLC feedback to the acknowledgements list</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-07
        <list style='symbols'>
          <t>Update to use the boilerplate from RFC 8174</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-06
        <list style='symbols'>
          <t>Add an appendix section describing the relationship of this document to OAuth Token Binding as
            requested during the Singapore meeting
            https://datatracker.ietf.org/doc/minutes-100-oauth/</t>
          <t>Add an explicit note that the implicit flow is not supported for obtaining certificate
            bound access tokens as discussed at the Singapore meeting
            https://datatracker.ietf.org/doc/minutes-100-oauth/</t>
          <t>Add/incorporate text to the Security Considerations on Certificate Spoofing as
            suggested https://mailarchive.ietf.org/arch/msg/oauth/V26070X-6OtbVSeUz_7W2k94vCo</t>
          <t>Changed the title to be more descriptive</t>
          <t>Move the Security Considerations section to before the IANA Considerations</t>
          <t>Elaborated on certificate-bound access tokens a bit more in the Abstract</t>
          <t>Update draft-ietf-oauth-discovery reference to -08</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-05
        <list style='symbols'>
          <t>Editorial fixes</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-04
        <list style='symbols'>
          <t>Change the name of the 'Public Key method' to the more accurate 'Self-Signed Certificate method' and
            also change the associated authentication method metadata value to "self_signed_tls_client_auth".</t>
          <t>Removed the "tls_client_auth_root_dn" client metadata field as discussed in
            https://mailarchive.ietf.org/arch/msg/oauth/swDV2y0be6o8czGKQi1eJV-g8qc</t>
          <t>Update draft-ietf-oauth-discovery reference to -07</t>
          <t>Clarify that MTLS client authentication isn't exclusive to the token endpoint
            and can be used with other endpoints, e.g. RFC 7009 revocation and 7662 introspection,
            that utilize client authentication as discussed in
            https://mailarchive.ietf.org/arch/msg/oauth/bZ6mft0G7D3ccebhOxnEYUv4puI</t>
          <t>Reorganize the document somewhat in an attempt to more clearly make a distinction between
            mTLS client authentication and certificate-bound access tokens as well as a more clear
            delineation between the two (PKI/Public key) methods for client authentication</t>
          <t>Editorial fixes and clarifications</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-03
        <list style='symbols'>
          <t>Introduced metadata and client registration parameter to publish and request
          support for mutual TLS sender constrained access tokens</t>
          <t>Added description of two methods of binding the cert and client, PKI and Public Key.</t>
          <t>Indicated that the "tls_client_auth" authentication method is for the PKI method and
            introduced "pub_key_tls_client_auth" for the Public Key method</t>
          <t>Added implementation considerations, mainly regarding TLS stack configuration
          and trust chain validation, as well as how to to do binding of access tokens to a TLS client
          certificate for public clients, and considerations around certificate-bound access tokens</t>
          <t>Added new section to security considerations on cert spoofing</t>
          <t>Add text suggesting that a new cnf member be defined in the future,
            if hash function(s) other than SHA-256 need to be used for certificate thumbprints</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-02
        <list style='symbols'>
          <t>Fixed editorial issue https://mailarchive.ietf.org/arch/msg/oauth/U46UMEh8XIOQnvXY9pHFq1MKPns</t>
          <t>Changed the title (hopefully "Mutual TLS Profile for OAuth 2.0" is better than "Mutual TLS Profiles for OAuth Clients").</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-01
        <list style='symbols'>
          <t>Added more explicit details of using RFC 7662 token introspection with mutual TLS sender constrained access tokens.</t>
          <t>Added an IANA OAuth Token Introspection Response Registration request for "cnf".</t>
          <t>Specify that tls_client_auth_subject_dn and tls_client_auth_root_dn are RFC 4514 String Representation of Distinguished Names.</t>
          <t>Changed tls_client_auth_issuer_dn to tls_client_auth_root_dn.</t>
          <t>Changed the text in the <xref target="CertificateBoundAccessTokens"/> to not be specific about using a hash of the cert.</t>
          <t>Changed the abbreviated title to 'OAuth Mutual TLS' (previously was the acronym MTLSPOC).</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-00
        <list style='symbols'>
          <t>Created the initial working group version from draft-campbell-oauth-mtls</t>
        </list>
      </t>
      <t>
      draft-campbell-oauth-mtls-01
      <list style='symbols'>
        <t>Fix some typos.</t>
        <t>Add to the acknowledgements list.</t>
      </list>
      </t>
      <t>
        draft-campbell-oauth-mtls-00
        <list style='symbols'>
          <t>
            Add a Mutual TLS sender constrained protected resource access method
            and a x5t#S256 cnf method for JWT access tokens
            (concepts taken in part from draft-sakimura-oauth-jpop-04).
          </t>
          <t>
            Fixed "token_endpoint_auth_methods_supported" to "token_endpoint_auth_method" for client metadata.
          </t>
          <t>
            Add "tls_client_auth_subject_dn" and "tls_client_auth_issuer_dn" client metadata parameters and
            mention using "jwks_uri" or "jwks".
          </t>
          <t>
            Say that the authentication method is determined by client policy regardless of whether the client
            was dynamically registered or statically configured.
          </t>
          <t>Expand acknowledgements to those that participated in discussions around
            draft-campbell-oauth-tls-client-auth-00</t>
          <t>
            Add Nat Sakimura and Torsten Lodderstedt to the author list.
          </t>
        </list>
      </t>
      <t>
        draft-campbell-oauth-tls-client-auth-00
        <list style='symbols'>
          <t>
            Initial draft.
	        </t>
        </list>
      </t>
      <?rfc subcompact="no"?>
    </section>     

  </back>
</rfc>