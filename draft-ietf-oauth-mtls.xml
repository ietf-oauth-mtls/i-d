<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-ietf-oauth-mtls-08"
     ipr="trust200902">
  <front>
    <title abbrev="OAuth Mutual TLS">OAuth 2.0 Mutual TLS Client Authentication and Certificate Bound Access Tokens</title>

    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address><email>brian.d.campbell@gmail.com</email></address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Yubico</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
        <uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
        <email>n-sakimura@nri.co.jp</email>
        <uri>https://nat.sakimura.org/</uri>
      </address>
    </author>

    <author fullname="Torsten Lodderstedt" initials="T." surname="Lodderstedt">
      <organization>YES Europe AG</organization>
      <address>
        <email>torsten@lodderstedt.net</email>
      </address>
    </author>


    <date />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>


    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>MTLS</keyword>
    <keyword>Mutual TLS</keyword>
    <keyword>proof-of-possession</keyword>
    <keyword>proof-of-possession access token</keyword>
    <keyword>sender constrained access token</keyword>
    <keyword>certificate bound access token</keyword>
    <keyword>sender constrained</keyword>
    <keyword>OAuth</keyword>


    <abstract>
<t>
  This document describes OAuth client authentication and sender-constrained tokens using
  mutual Transport Layer Security (TLS) authentication with X.509 certificates.
  OAuth clients are provided a mechanism for authentication to the authorization
  sever using mutual TLS, based on either single certificates or public key infrastructure (PKI).
  OAuth authorization servers are provided a mechanism for binding access tokens to a client's
  mutual TLS certificate, and OAuth protected resources are provided a method for ensuring
  that such an access token presented to it was issued to the client presenting the token.
</t>
    </abstract>

  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
<t>
  This document describes mutual Transport Layer Security (TLS) authentication
  using X.509 certificates as a mechanism for OAuth client authentication
  to the authorization sever as well as for sender constrained access to
  OAuth protected resources.
</t>
<t>
  The OAuth 2.0 Authorization Framework <xref target="RFC6749"/>
  defines a shared secret method of client authentication but also
  allows for the definition and use of additional client authentication mechanisms
  when interacting directly with the authorization server.
  This document describes an additional mechanism of client authentication utilizing
  mutual TLS <xref target="RFC5246"/> certificate-based authentication, which provides
  better security characteristics than shared secrets.
  While <xref target="RFC6749"/> documents client authentication for requests to the token endpoint,
  extensions to OAuth 2.0 (such as <xref target="RFC7662">Introspection</xref> and
  <xref target="RFC7009">Revocation</xref>) define endpoints that also utilize client authentication
  and the mutual TLS methods defined herein are applicable to those endpoints as well.
</t>

<t>
  Mutual TLS sender constrained access to protected resources ensures that
  only the party in possession of the
  private key corresponding to the certificate can utilize the access token to get
  access to the associated resources. Such a constraint is unlike the case of the
  bearer token described in <xref target="RFC6750"/>, where any party in
  possession of the access token can use it to access the associated resources.
  Mutual TLS sender constrained access binds the access token to the client's certificate
  thus preventing the use of stolen access tokens or replay of access tokens
  by unauthorized parties.
</t>
<t>
  Mutual TLS sender constrained access tokens and mutual TLS client authentication
  are distinct mechanisms, which are complementary but don't necessarily need to be deployed together.
</t>
    <section anchor="RNC" title="Requirements Notation and Conventions">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL"
  in this document are to be interpreted as described in
  BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
  when, and only when, they appear in all capitals, as shown here.
</t>
    </section>

    <section anchor="Terminology" title="Terminology">
<t>
  Mutual TLS refers to the process whereby a client presents its X.509 certificate
  and proves possession of the corresponding private key to a server when negotiating a TLS session.

  In <xref target="RFC5246">TLS 1.2</xref> this requires the client to send
  Client Certificate and Certificate Verify messages during the TLS handshake and
  for the server to verify these messages.
</t>
    </section>

    </section>
    <section anchor="mtlsca" title="Mutual TLS for OAuth Client Authentication">
<t>
  This section defines, as an extension of
  <xref target="RFC6749">OAuth 2.0, Section 2.3</xref>, two distinct methods of using
  mutual TLS X.509 client certificates as client credentials.

  The requirement of mutual TLS for client authentication is determined by the authorization server
  based on policy or configuration for the given client (regardless of whether the client was dynamically
  registered, statically configured, or otherwise established).
</t>
<t>
  In order to utilize TLS for OAuth client authentication, the TLS
  connection between the client and the authorization server MUST have been established or reestablished
  with mutual TLS X.509 certificate authentication
  (i.e. the Client Certificate and Certificate Verify messages are sent during the TLS Handshake
  <xref target="RFC5246"/>).
</t>
<t>
  For all requests to the authorization server utilizing mutual TLS client authentication,
  the client MUST include the <spanx style='verb'>client_id</spanx> parameter,
  described in <xref target="RFC6749">OAuth 2.0, Section 2.2</xref>.
  The presence of the <spanx style='verb'>client_id</spanx>
  parameter enables the authorization server to easily identify the
  client independently from the content of the certificate. The authorization server
  can locate the client configuration using the client identifier and check the certificate
  presented in the TLS Handshake against the expected credentials for that client.
  The authorization server MUST enforce the
  binding of a certificate to a specific client as described in either <xref target="pki_method"/> or
  <xref target="self_signed_method"/> below.
</t>

    <section anchor="pki_method" title="PKI Mutual TLS OAuth Client Authentication Method">
      <t>
        The PKI (public key infrastructure) method of mutual TLS OAuth client authentication uses
        a subject distinguished name (DN) and validated certificate chain to identify
        the client. The TLS handshake is utilized to validate the client's possession
        of the private key corresponding to the public key in the certificate and to
        validate the corresponding certificate chain. The client is successfully authenticated
        if the subject information in the certificate matches the expected DN configured or
        registered for that particular client
        (note that a predictable treatment of DN values, such as the distinguishedNameMatch
        rule from <xref target="RFC4517"/>, is needed in comparing the
        certificate's subject DN to the client's registered DN).
        The PKI method facilitates the way X.509 certificates are traditionally being used
        for authentication. It also allows the client to rotate its X.509 certificates
        without the need to modify its respective authentication data at the authorization
        server by obtaining a new certificate with the same subject DN from a trusted certificate authority (CA).
      </t>

      <section anchor="metadata_auth_value_pki" title="PKI Authentication Method Metadata Value">
        <t>
          The "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/> contains values, each of which specify a
          method of authenticating a client to the authorization server.  The values are
          used to indicate supported and utilized client authentication methods
          in authorization server metadata, such as
          <xref target="OpenID.Discovery">OpenID Connect Discovery</xref> and
          <xref target="I-D.ietf-oauth-discovery">OAuth 2.0 Authorization Server Metadata</xref>,
          and in the
          <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>.
          For the PKI method of mutual TLS client authentication, this specification
          defines and registers the following authentication method metadata value.
        </t>
        <t>
          <list style="hanging">
            <t hangText="tls_client_auth">
              <vspace/>
              Indicates that client authentication to the authorization server will occur with
              mutual TLS utilizing the PKI method of associating a certificate to a client.
            </t>
          </list>
        </t>
      </section>

      <section anchor="client_metadata_pki" title="Client Registration Metadata">
        <t>
          The following metadata
          parameter is introduced for the
          <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref> in support of
          the PKI method of binding a certificate to a client:
          <list style="hanging">
            <t hangText="tls_client_auth_subject_dn"><vspace/>
              An <xref target="RFC4514"/> string representation of the expected subject distinguished
              name of the certificate the OAuth client will use in mutual TLS authentication.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="self_signed_method" title="Self-Signed Certificate Mutual TLS OAuth Client Authentication Method">
      <t>
        This method of mutual TLS OAuth client authentication
        is intended to support client authentication using self-signed certificates.
        As pre-requisite, the client registers an X.509 certificate or a trusted source
        for its X.509 certificates (such as the <spanx style="verb">jwks_uri</spanx> defined in <xref target="RFC7591"/>
        that references a <xref target="RFC7517">JSON Web Key</xref> Set
        containing the client's certificates and public keys) with
        the authorization server. During authentication,
        TLS is utilized to validate the client's possession of the private key
        corresponding to the public key presented within the certificate in the respective TLS handshake. In
        contrast to the PKI method, the client's certificate chain is not validated by the server in this case.
        The client is successfully authenticated if the subject public key info of the
        certificate matches the subject public key info of one of the certificates
        configured or registered for that particular client.
        The Self-Signed Certificate method allows to use mutual TLS to authenticate clients without
        the need to maintain a PKI. When used in conjunction with a <spanx style="verb">jwks_uri</spanx> for the
        client, it also allows the client to rotate its X.509 certificates without the
        need to change its respective authentication data directly with the authorization server.
      </t>
      <section anchor="metadata_auth_value_self_signed" title="Self-Signed Certificate Authentication Method Metadata Value">

        <t>
          The "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/> contains values, each of which specify a
          method of authenticating a client to the authorization server.  The values are
          used to indicate supported and utilized client authentication methods
          in authorization server metadata, such as
          <xref target="OpenID.Discovery">OpenID Connect Discovery</xref> and
          <xref target="I-D.ietf-oauth-discovery">OAuth 2.0 Authorization Server Metadata</xref>,
          and in the
          <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>.
          For the Self-Signed Certificate method of binding a certificate to a client using mutual
          TLS client authentication, this specification
          defines and registers the following authentication method metadata value.
        </t>
        <t>
          <list style="hanging">
            <t hangText="self_signed_tls_client_auth">
              <vspace/>
              Indicates that client authentication to the authorization server will occur using
              mutual TLS with the client utilizing a self-signed certificate.
            </t>
          </list>
        </t>
      </section>

      <section anchor="client_metadata_self_signed" title="Client Registration Metadata">
        <t>
          For the Self-Signed Certificate method of binding a certificate to a client using mutual
          TLS client authentication, the existing
          <spanx style="verb">jwks_uri</spanx> or <spanx style="verb">jwks</spanx>
          metadata parameters from <xref target="RFC7591"/> are used to convey the client's
          certificates and public keys, where the X.509
          certificates are represented using the <xref target="RFC7517">JSON Web Key (JWK)</xref>
          <spanx style="verb">x5c</spanx> parameter (note that Sec 4.7 of RFC 7517
          requires that the key in the first certificate of the <spanx style="verb">x5c</spanx> parameter
          must match the public key represented by other members of the JWK).
        </t>
      </section>
    </section>

    </section>

    <section anchor="SenderConstrainedAccess" title="Mutual TLS Sender Constrained Resources Access">
<t>
  When mutual TLS is used by the client on the connection to the token endpoint,
  the authorization server is able to bind the issued access token to the client certificate.
  Such a binding is accomplished by associating the certificate with the token in
  a way that can be accessed by the protected resource, such as embedding the certificate
  hash in the issued access token directly, using the syntax described in <xref target="x5t256"/>,
  or through token introspection as described in <xref target="introspect"/>.
  Other methods of associating a certificate with an access token are possible,
  per agreement by the authorization server and the protected resource, but are
  beyond the scope of this specification.
</t>
<t>
  The client makes protected resource requests as described in <xref target="RFC6750"/>,
  however, those requests MUST be made over a mutually authenticated TLS connection
  using the same certificate that was used for mutual TLS at the token endpoint.
</t>
<t>
  The protected resource MUST obtain the client certificate
  used for mutual TLS authentication
  and MUST verify that the certificate matches the
  certificate associated with the access token.  If they do not match,
  the resource access attempt MUST be rejected with an error per <xref target="RFC6750"/>
  using an HTTP 401 status code and the <spanx style="verb">invalid_token</spanx> error code.
</t>
<t>
  Metadata to convey server and client capabilities for mutual TLS sender constrained access tokens
  is defined in <xref target="server_metadata_at"/> and <xref target="client_metadata_at"/> respectively.
</t>

      <section anchor="x5t256" title="X.509 Certificate Thumbprint Confirmation Method for JWT">
  <t>
    When access tokens are represented as JSON Web Tokens (JWT)<xref target="RFC7519"/>,
    the certificate hash information SHOULD be represented using
    the <spanx style="verb">x5t#S256</spanx> confirmation method member defined herein.
  </t>
  <t>
    To represent the hash of a certificate in a JWT,
    this specification defines the new <xref target="RFC7800">JWT Confirmation Method</xref>
    member <spanx style="verb">x5t#S256</spanx> for the X.509 Certificate SHA-256 Thumbprint.
    The value of the <spanx style="verb">x5t#S256</spanx> member is
    the SHA-256<xref target="SHS"/> hash (a.k.a. thumbprint, fingerprint or digest)
    of the DER encoding of the X.509 certificate <xref target="RFC5280"/>
    <xref target="RFC4648">base64url-encoded</xref> with with all trailing pad '=' characters omitted and without
    the inclusion of any line breaks, whitespace, or other additional characters.
  </t>
  <t>
    The following is an example of a JWT payload containing an <spanx style="verb">x5t#S256</spanx> certificate thumbprint
    confirmation method.
  </t>

  <figure anchor="eg_x5ts256jwt" title="Example claims of a Certificate Thumbprint Constrained JWT">
    <artwork><![CDATA[
  {
    "iss": "https://server.example.com",
    "sub": "ty.webb@example.com",
    "exp": 1493726400,
    "nbf": 1493722800,
    "cnf":{
      "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
  }]]>
    </artwork>
  </figure>

   <t>
     If, in the future, certificate thumbprints need to be computed using
     hash functions other than SHA-256, it is suggested that additional
     related JWT confirmation methods members be defined for that purpose.
     For example, a new <spanx style="verb">x5t#S512</spanx> (X.509 Certificate Thumbprint
     using SHA-512) confirmation method member could be defined by registering it in
     the the IANA "JWT Confirmation Methods" registry
     <xref target="IANA.JWT.Claims"/>
     for JWT <spanx style="verb">cnf</spanx> member values
     established by <xref target="RFC7800"/>.
   </t>
      </section>

      <section anchor="introspect" title="Confirmation Method for Token Introspection">
        <t>
          <xref target="RFC7662">OAuth 2.0 Token Introspection</xref> defines a
          method for a protected resource to query
          an authorization server about the active state of an
          access token as well as to determine meta-information about the token.
        </t>
        <t>
          For a mutual TLS sender constrained access token, the hash of the
          certificate to which the token is bound
          is conveyed to the protected resource as meta-information
          in a token introspection response. The hash is conveyed using the same structure as the
          certificate SHA-256 thumbprint confirmation method, described in
          <xref target="x5t256"/>, as a top-level member of the introspection response JSON.
          The protected resource compares
          that certificate hash to a hash of the client certificate used for
          mutual TLS authentication
          and rejects the request, if they do not match.
        </t>
        <t>
          <xref target="RFC7800">Proof-of-Possession Key Semantics for JSON Web Tokens</xref> defined the
          <spanx style="verb">cnf</spanx> (confirmation) claim, which enables
          confirmation key information to be carried in a JWT.
          However, the same proof-of-possession semantics are also useful for introspected access tokens
          whereby the protected resource obtains the confirmation key data as meta-information
          of a token introspection response and uses that information in verifying proof-of-possession.
          Therefore this specification defines and registers proof-of-possession semantics for
          <xref target="RFC7662">OAuth 2.0 Token Introspection</xref> using the <spanx style="verb">cnf</spanx>
          structure.
          When included as a top-level member of an OAuth token introspection response, <spanx style="verb">cnf</spanx>
          has the same semantics and format as the claim of the same name defined in <xref target="RFC7800"/>.
          While this specification only explicitly uses the <spanx style="verb">x5t#S256</spanx>
          confirmation method member, it needed to define and register the higher level <spanx style="verb">cnf</spanx>
          structure as an introspection response member in order to define and use its more specific
          <spanx style="verb">x5t#S256</spanx> confirmation method.
        </t>

        <t>
          The following is an example of an introspection response for an active token with
          an <spanx style="verb">x5t#S256</spanx> certificate thumbprint
          confirmation method.
        </t>

        <figure anchor="eg_x5ts256intro" title="Example Introspection Response for a Certificate Constrained Access Token">
          <artwork><![CDATA[

  HTTP/1.1 200 OK
  Content-Type: application/json

  {
    "active": true,
    "iss": "https://server.example.com",
    "sub": "ty.webb@example.com",
    "exp": 1493726400,
    "nbf": 1493722800,
    "cnf":{
      "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
  }]]>
          </artwork>
        </figure>

      </section>

      <section anchor="server_metadata_at" title="Authorization Server Metadata">
          <t>This document introduces the following new authorization server
            metadata parameter to signal the server's capability to issue certificate
            bound access tokens:

            <list style="hanging">
              <t hangText="mutual_tls_sender_constrained_access_tokens"><vspace/>
                OPTIONAL.  Boolean value indicating server support for
                mutual TLS sender constrained access tokens. If omitted, the
                default value is <spanx style="verb">false</spanx>.
              </t>
            </list>
          </t>
        </section>

      <section anchor="client_metadata_at" title="Client Registration Metadata">
        <t>The following new client
          metadata parameter is introduced to convey the client's intention to use certificate
          bound access tokens:

          <list style="hanging">
            <t hangText="mutual_tls_sender_constrained_access_tokens"><vspace/>
              OPTIONAL. Boolean value used to indicate the client's intention
              to use mutual TLS sender constrained access tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
            </t>
          </list>
        </t>
        </section>

      </section>


    
    <section anchor="Impl" title="Implementation Considerations">
    <section anchor="ImplAS" title="Authorization Server">
    <t>The authorization server needs to set up its TLS configuration appropriately
    for the binding methods it supports.</t>
    <t>If the authorization server wants to support mutual TLS client authentication 
    and other client authentication methods in parallel, it should make mutual TLS
    optional.</t>
    <t>If the authorization server supports the Self-Signed Certificate method, it
    should configure the TLS stack in a way that it does not verify whether the 
    certificate presented by the client during the handshake is signed by a trusted CA 
    certificate.</t>
    <t>The authorization server may also consider hosting the token endpoint,
    and other endpoints requiring client authentication, on
    a separate host name in order to prevent unintended impact on the TLS behavior of
    its other endpoints, e.g. authorization or registration.</t>
    </section>
    <section anchor="ImplRS" title="Resource Server">
    <t>From the perspective of the resource server, TLS client authentication is 
    used as a proof of possession method only. For the purpose of client authentication,
    the resource server may completely rely on the authorization server. So there is 
    no need to validate the trust chain of the client's certificate in any of the methods
    defined in this document. The resource server should therefore configure the TLS stack
    in a way that it does not verify whether the certificate presented by the client 
    during the handshake is signed by a trusted CA certificate.</t>
    </section>
    <section anchor="ImplPubClient" title="Sender Constrained Access Tokens Without Client Authentication">
    <t>
    This document allows use of client authentication only or client authentication in
    combination with sender constraint access tokens. Use of mutual TLS sender
    constrained access tokens without client authentication (e.g. to support
    binding access tokens to a TLS client certificate for public clients) is also possible.
    The authorization server would configure the TLS stack in the same manner as for the Self-Signed Certificate method
    such that it does not verify that the certificate presented by the client during the handshake is
    signed by a trusted CA. Individual instances of a public client would then create a self-signed
    certificate for mutual TLS with the authorization server and resource server. The authorization
    server would not authenticate the client at the OAuth layer but would bind issued access tokens
    to the certificate, which the client has proven possession of the corresponding private key.
    The access token is then mutual TLS sender constrained and can only be used by the client
    possessing the certificate and private key and utilizing them to negotiate mutual TLS on
    connections to the resource server.
    </t>
    </section>
    <section anchor="ImplExp" title="Certificate Bound Access Tokens">
      <t>
        As described in <xref target="SenderConstrainedAccess"/>,
        an access token is bound to a specific client certificate, which means that
        the same certificate must be used for mutual TLS on protected resource access.
        It also implies that access tokens are invalidated when a client updates the certificate,
        which can be handled similar to expired access tokens where the client
        requests a new access token (typically with a refresh token) and retries the protected resource
        request.
      </t>
    </section>
    <section anchor="ImplImplicit" title="Implicit Grant Unsupported">
    <t>
      This document describes binding an access token to the
      client certificate presented on the TLS connection from the client to the
      authorization server's token endpoint,
      however, certificate binding of access tokens issued directly from the authorization
      endpoint via the implicit grant flow is explicitly out of scope.
      End users interact directly with the authorization endpoint using a web browser
      and the use of client certificates in user's browsers bring operational and
      usability issues, which make it undesirable to support certificate bound access
      tokens issued in the implicit grant flow. Implementations wanting to employ
      certificate bound sender constrained access tokens should utilize grant types
      that involve the client making an access token request directly to the token endpoint
      (e.g. the authorization code and refresh token grant types).
    </t>
    </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <section anchor="TLSV" title="TLS Versions and Best Practices">
        <t>
          <xref target="RFC5246">TLS 1.2</xref> is cited in this document because,
          at the time of writing, it is the latest version that is widely deployed.
          However, this document is applicable with other TLS versions supporting
          certificate-based client authentication.
          Implementation security considerations for TLS, including version recommendations,
          can be found in
          <xref target="BCP195">Recommendations for Secure Use of Transport Layer Security (TLS)
            and Datagram Transport Layer Security (DTLS)</xref>.
        </t>
      </section>
      <section anchor="certspoofing" title="X.509 Certificate Spoofing">
        <t>
          If the PKI method of client authentication is used, an attacker could try to impersonate a client using
          a certificate with the same subject DN but issued by a different CA, which the authorization server trusts.
          To cope with that threat, the authorization server should only accept as trust anchors
          a limited number of CAs whose certificate issuance policy meets its security requirements.
          There is an assumption then that the client and server agree on the set
          of trust anchors that the server uses to create and validate the
          certificate chain. Without this assumption the use of a Subject DN
          to identify the client certificate would open the server up to
          certificate spoofing attacks.
        </t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="cnfIANA" title="JWT Confirmation Methods Registration">
        <t>
          This specification requests registration of the following value
          in the IANA "JWT Confirmation Methods" registry
          <xref target="IANA.JWT.Claims"/>
          for JWT <spanx style="verb">cnf</spanx> member values
          established by <xref target="RFC7800"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Confirmation Method Value: <spanx style="verb">x5t#S256</spanx></t>
            <t>Confirmation Method Description: X.509 Certificate SHA-256 Thumbprint</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="x5t256"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
      
      <section anchor="ietf-oauth-discoveryIANA" title="OAuth Authorization Server Metadata Registration">
        <t>
          This specification requests registration of the following value
          in the IANA "OAuth Authorization Server Metadata" registry
          <xref target="IANA.OAuth.Parameters"/> established by <xref target="I-D.ietf-oauth-discovery"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Metadata Name: <spanx style="verb">mutual_tls_sender_constrained_access_tokens</spanx></t>
            <t>Metadata Description: Indicates authorization server support for mutual TLS sender constrained
              access tokens.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="server_metadata_at"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>

      <section anchor="tls_client_authIANA" title="Token Endpoint Authentication Method Registration">
        <t>
          This specification requests registration of the following value
          in the IANA "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/> established by <xref target="RFC7591"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">tls_client_auth</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="metadata_auth_value_pki"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">self_signed_tls_client_auth</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="metadata_auth_value_self_signed"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>

      <section anchor="intorspectIANA" title="OAuth Token Introspection Response Registration">

        <t>
          This specification requests registration of the following value
          in the IANA "OAuth Token Introspection Response" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7662"/>.
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Claim Name: <spanx style="verb">cnf</spanx></t>
            <t>Claim Description: Confirmation</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="introspect"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>


      <section anchor="DynRegReg" title="OAuth Dynamic Client Registration Metadata Registration">
        <t>
          This specification requests registration of the following client metadata definitions
          in the IANA "OAuth Dynamic Client Registration Metadata" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7591"/>:
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">mutual_tls_sender_constrained_access_tokens</spanx>
            </t>
            <t>
              Client Metadata Description:
              Indicates the client's intention to use mutual TLS sender constrained
              access tokens.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_at"/> of [[ this specification ]]
            </t>
          </list>
        </t>
        <t>
          <list style="symbols">
            <t>
              Client Metadata Name: <spanx style="verb">tls_client_auth_subject_dn</spanx>
            </t>
            <t>
              Client Metadata Description:
              String value specifying the expected subject distinguished name of the
              client certificate.
            </t>
            <t>
              Change Controller: IESG
            </t>
            <t>
              Specification Document(s): <xref target="client_metadata_pki"/> of [[ this specification ]]
            </t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.4514'?> <!-- LDAP: String Representation of Distinguished Names -->
      <?rfc include='reference.RFC.4648'?> <!-- base64 -->
      <?rfc include='reference.RFC.5246'?> <!-- TLS 1.2 -->
      <?rfc include='reference.RFC.5280'?> <!-- X.509 Public Key Infrastructure Certificate ... -->
      <?rfc include='reference.RFC.6749'?> <!-- OAuth 2.0 Authorization Framework -->
      <?rfc include='reference.RFC.6750'?> <!-- OAuth 2.0 Authorization Framework: Bearer Token Usage -->

      <?rfc include='reference.RFC.7800'?>
      <reference anchor="BCP195" target="http://www.rfc-editor.org/info/bcp195">
        <front>
          <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
          <author initials="Y." surname="Sheffer" fullname="Y. Sheffer">
            <organization/>
          </author>
          <author initials="R." surname="Holz" fullname="R. Holz">
            <organization/>
          </author>
          <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
            <organization/>
          </author>
          <date year="2015" month="May"/>
          <abstract>
            <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP. Over the last
              few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation. This document provides recommendations for improving the
              security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.
            </t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="195"/>
        <seriesInfo name="RFC" value="7525"/>
        <seriesInfo name="DOI" value="10.17487/RFC7525"/>
      </reference>

      <reference anchor="SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
              Technology</organization>
          </author>

          <date month="March" year="2012" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" type="PDF" />
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="IANA.JWT.Claims" target="http://www.iana.org/assignments/jwt">
        <front>
          <title>JSON Web Token Claims</title>
          <author>
            <organization>IANA</organization>
          </author>
          <date/>
        </front>
      </reference>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-discovery-08.xml'?>

      <?rfc include='reference.RFC.4517'?>
      <?rfc include='reference.RFC.7009'?> <!-- revocation -->
      <?rfc include='reference.RFC.7517'?> <!-- JWK -->
      <?rfc include='reference.RFC.7519'?> <!-- JWT -->
      <?rfc include='reference.RFC.7591'?> <!-- Dynamic Client Registration -->
      <?rfc include='reference.RFC.7662'?> <!-- introspection -->
      <?rfc include='reference.RFC.8174'?>

      <?rfc include='http://openid.net/bibxml/reference.OpenID.Discovery.xml'?>

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-token-binding-05.xml'?>

    </references>

    <section anchor="relation" title="Relationship to Token Binding">
      <t>
        <xref target="I-D.ietf-oauth-token-binding">OAuth 2.0 Token Binding</xref>
        enables the application of Token Binding to the various artifacts and tokens employed throughout OAuth.
        That includes binding of an access token to a Token Binding key, which bears some similarities in motivation
        and design to the mutual TLS sender constrained resources access defined in this document.
        Both documents define what is often called a proof-of-possession security mechanism
        for access tokens, whereby a client must demonstrate possession of cryptographic keying
        material when accessing a protected resource. The details differ somewhat between the two documents but both
        have the authorization server bind the access token it issues to an asymmetric key pair
        on the client. The client then proves possession of the private key from that pair
        on the TLS connection over which the protected resource is accessed.
      </t>
      <t>
        The two documents then are effectively competing specifications, at least with respect to the
        binding of access tokens.
        Token Binding uses bare keys that are generated on the client,
        which avoids many of the difficulties of creating, distributing, and managing certificates
        and has the potential to see wider scale adoption and deployment. However, at the time of
        writing, Token Binding is fairly new and there is relatively little support for it in available
        application development platforms and tooling. Until better support for the underlying
        core Token Binding specifications exists, practical implementations of OAuth 2.0 Token Binding
        are infeasible. Despite its name, Token Binding doesn't have a monopoly on the binding of tokens.
        Mutual TLS, on the other hand, has been around for some time and enjoys
        widespread support in web servers and development platforms. Mutual TLS for OAuth 2.0 can be
        built and deployed now using existing platforms and tools.
        There are emerging and immediate scenarios, such as OAuth enabled financial transactions motivated by
        regulatory requirements in some cases, which demand the additional security protections
        of proof-of-possession access tokens.  This document aspires to provide standardized and expeditious solution
        for those scenarios.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        Scott "not Tomlinson" Tomilson and Matt Peterson were involved in
        design and development work on a mutual TLS OAuth client authentication
        implementation that informed some of the content of this document.
      </t>

      <t>
        Additionally, the authors would like to thank the following people for
        their input and contributions to the specification:
        Sergey Beryozkin,
        Vladimir Dzhuvinov,
        Samuel Erdtman,
        Leif Johansson,
        Phil Hunt,
        Takahiko Kawasaki,
        Sean Leonard,
        Kepeng Li,
        James Manger,
        Jim Manico,
        Nov Matake,
        Sascha Preibisch,
        Justin Richer,
        Dave Tonge,
        and
        Hannes Tschofenig.
      </t>
    </section>


    <section anchor="History" title="Document(s) History">
      <?rfc subcompact="yes"?>
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>
      <t>
        draft-ietf-oauth-mtls-08
        <list style='symbols'>
          <t></t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-07
        <list style='symbols'>
          <t>Update to use the boilerplate from RFC 8174</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-06
        <list style='symbols'>
          <t>Add an appendix section describing the relationship of this document to OAuth Token Binding as
            requested during the the Singapore meeting
            https://datatracker.ietf.org/doc/minutes-100-oauth/</t>
          <t>Add an explicit note that the implicit flow is not supported for obtaining certificate
            bound access tokens as discussed at the Singapore meeting
            https://datatracker.ietf.org/doc/minutes-100-oauth/</t>
          <t>Add/incorporate text to the Security Considerations on Certificate Spoofing as
            suggested https://mailarchive.ietf.org/arch/msg/oauth/V26070X-6OtbVSeUz_7W2k94vCo</t>
          <t>Changed the title to be more descriptive</t>
          <t>Move the Security Considerations section to before the IANA Considerations</t>
          <t>Elaborated on certificate bound access tokens a bit more in the Abstract</t>
          <t>Update draft-ietf-oauth-discovery reference to -08</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-05
        <list style='symbols'>
          <t>Editorial fixes</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-04
        <list style='symbols'>
          <t>Change the name of the 'Public Key method' to the more accurate 'Self-Signed Certificate method' and
            also change the associated authentication method metadata value to "self_signed_tls_client_auth".</t>
          <t>Removed the "tls_client_auth_root_dn" client metadata field as discussed in
            https://mailarchive.ietf.org/arch/msg/oauth/swDV2y0be6o8czGKQi1eJV-g8qc</t>
          <t>Update draft-ietf-oauth-discovery reference to -07</t>
          <t>Clarify that MTLS client authentication isn't exclusive to the token endpoint
            and can be used with other endpoints, e.g. RFC 7009 revocation and 7662 introspection,
            that utilize client authentication as discussed in
            https://mailarchive.ietf.org/arch/msg/oauth/bZ6mft0G7D3ccebhOxnEYUv4puI</t>
          <t>Reorganize the document somewhat in an attempt to more clearly make a distinction between
            mTLS client authentication and certificate bound access tokens as well as a more clear
            delineation between the two (PKI/Public key) methods for client authentication</t>
          <t>Editorial fixes and clarifications</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-03
        <list style='symbols'>
          <t>Introduced metadata and client registration parameter to publish and request
          support for mutual TLS sender constrained access tokens</t>
          <t>Added description of two methods of binding the cert and client, PKI and Public Key.</t>
          <t>Indicated that the "tls_client_auth" authentication method is for the PKI method and
            introduced "pub_key_tls_client_auth" for the Public Key method</t>
          <t>Added implementation considerations, mainly regarding TLS stack configuration
          and trust chain validation, as well as how to to do binding of access tokens to a TLS client
          certificate for public clients, and considerations around certificate bound access tokens</t>
          <t>Added new section to security considerations on cert spoofing</t>
          <t>Add text suggesting that a new cnf member be defined in the future,
            if hash function(s) other than SHA-256 need to be used for certificate thumbprints</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-02
        <list style='symbols'>
          <t>Fixed editorial issue https://mailarchive.ietf.org/arch/msg/oauth/U46UMEh8XIOQnvXY9pHFq1MKPns</t>
          <t>Changed the title (hopefully "Mutual TLS Profile for OAuth 2.0" is better than "Mutual TLS Profiles for OAuth Clients").</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-01
        <list style='symbols'>
          <t>Added more explicit details of using RFC 7662 token introspection with mutual TLS sender constrained access tokens.</t>
          <t>Added an IANA OAuth Token Introspection Response Registration request for "cnf".</t>
          <t>Specify that tls_client_auth_subject_dn and tls_client_auth_root_dn are RFC 4514 String Representation of Distinguished Names.</t>
          <t>Changed tls_client_auth_issuer_dn to tls_client_auth_root_dn.</t>
          <t>Changed the text in the <xref target="SenderConstrainedAccess"/> to not be specific about using a hash of the cert.</t>
          <t>Changed the abbreviated title to 'OAuth Mutual TLS' (previously was the acronym MTLSPOC).</t>
        </list>
      </t>
      <t>
        draft-ietf-oauth-mtls-00
        <list style='symbols'>
          <t>Created the initial working group version from draft-campbell-oauth-mtls</t>
        </list>
      </t>
      <t>
      draft-campbell-oauth-mtls-01
      <list style='symbols'>
        <t>Fix some typos.</t>
        <t>Add to the acknowledgements list.</t>
      </list>
      </t>
      <t>
        draft-campbell-oauth-mtls-00
        <list style='symbols'>
          <t>
            Add a Mutual TLS sender constrained protected resource access method
            and a x5t#S256 cnf method for JWT access tokens
            (concepts taken in part from draft-sakimura-oauth-jpop-04).
          </t>
          <t>
            Fixed "token_endpoint_auth_methods_supported" to "token_endpoint_auth_method" for client metadata.
          </t>
          <t>
            Add "tls_client_auth_subject_dn" and "tls_client_auth_issuer_dn" client metadata parameters and
            mention using "jwks_uri" or "jwks".
          </t>
          <t>
            Say that the authentication method is determined by client policy regardless of whether the client
            was dynamically registered or statically configured.
          </t>
          <t>Expand acknowledgements to those that participated in discussions around
            draft-campbell-oauth-tls-client-auth-00</t>
          <t>
            Add Nat Sakimura and Torsten Lodderstedt to the author list.
          </t>
        </list>
      </t>
      <t>
        draft-campbell-oauth-tls-client-auth-00
        <list style='symbols'>
          <t>
            Initial draft.
	        </t>
        </list>
      </t>
      <?rfc subcompact="no"?>
    </section>     

  </back>
</rfc>